import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };

  // State for active tab and content types
  const [activeTab, setActiveTab] = useState('home');
  const [contentTypes] = useState([
    { id: 'home', name: 'Home Page' },
    { id: 'events', name: 'Event Categories' },
    { id: 'gallery', name: 'Gallery' }
  ]);

  // State for content data
  const [homeContent, setHomeContent] = useState(null);
  const [eventCategories, setEventCategories] = useState([]);
  const [galleryItems, setGalleryItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for editing
  const [editingItem, setEditingItem] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [galleryTab, setGalleryTab] = useState('photos'); // For gallery sub-tabs

  // State for preview images
  const [previewImages, setPreviewImages] = useState({});
  const [selectedFiles, setSelectedFiles] = useState({});

  // Fetch all content on component mount and tab change
  useEffect(() => {
    fetchAllContent();
  }, [activeTab, galleryTab]);

  const fetchAllContent = async () => {
    setLoading(true);
    setError(null);
    try {
      if (activeTab === 'home') {
        // Fetch home page content from MongoDB
        const response = await axiosInstance.get('/api/content/home');
        if (response.data.success) {
          setHomeContent(response.data.data);
        } else {
          throw new Error(response.data.message || 'Failed to fetch home content');
        }
      } else if (activeTab === 'events') {
        try {
          console.log('Fetching event categories from:', `/api/content/events/categories`);
          
          const response = await axiosInstance.get(`/api/content/events/categories`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Event categories response:', response.data);
          
          if (response.data.success) {
            // Directly use the response data array
            setEventCategories(response.data.data || []);
          } else {
            throw new Error(response.data.message || 'Failed to fetch event categories');
          }
        } catch (error) {
          console.error('Error details:', {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          
          if (error.response?.status === 401) {
            throw new Error('Authentication failed. Please log in again.');
          } else if (error.response?.status === 404) {
            throw new Error('Event categories endpoint not found. Please check the API URL.');
          } else {
            throw new Error(error.response?.data?.message || error.message || 'Failed to fetch event categories');
          }
        }
      } else if (activeTab === 'gallery') {
        const items = await getGalleryItems(galleryTab === 'photos' ? 'photo' : 'video');
        setGalleryItems(items);
      }
    } catch (err) {
      console.error('Error fetching content:', err);
      setError(err.message || 'Failed to fetch content. Please try again.');
      toast.error(err.message || 'Failed to fetch content. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add showNotification function
  const showNotification = (message, type = 'success') => {
    toast[type](message, {
      duration: 3000,
      position: 'top-right',
    });
  };

  // Update handleDelete function
  const handleDelete = async (type, id) => {
    try {
      let endpoint;
      switch (type) {
        case 'hero-slide':
          endpoint = `${API_BASE_URL}/api/content/home/hero-slide/${id}`;
          break;
        case 'leadership-member':
          endpoint = `${API_BASE_URL}/api/content/home/leadership/members/${id}`;
          break;
        case 'event-category':
          endpoint = `${API_BASE_URL}/api/content/events/categories/${id}`;
          break;
        case 'gallery':
          endpoint = `${API_BASE_URL}/api/content/gallery/${id}`;
          break;
        default:
          throw new Error('Invalid content type');
      }

      console.log('Deleting item:', { id, type, endpoint });

      const response = await axiosInstance.delete(endpoint);

      if (response.data.success) {
        showNotification('Item deleted successfully');
        // Refresh the content
</original_code>```

```
import React, { useState, useEffect } from 'react';
import { 
  PencilIcon, 
  TrashIcon, 
  PlusIcon, 
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import {
  getEventCategories,
  createEventCategory,
  updateEventCategory,
  deleteEventCategory,
  getGalleryItems,
  createGalleryItem,
  updateGalleryItem,
  deleteGalleryItem
} from "../../services/crudapi";
import axiosInstance from '../../utils/axiosConfig';
import { FaCalendar, FaUsers, FaGem, FaClock, FaDownload } from 'react-icons/fa';
import { toast } from 'react-hot-toast';
import { uploadToCloudinary, deleteFromCloudinary, FOLDERS } from '../../config/cloudinary';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:3000').replace(/\/$/, '');

const ContentManagement = () => {
  // Helper function to construct image URLs
  const getImageUrl = (imagePath) => {
    if (!imagePath) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    // If it's already a full URL (including Cloudinary URLs), return as is
    if (imagePath.startsWith('http')) return imagePath;
    // For any other case, return the data URL placeholder
    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
  };

  // Add this helper function for image error handling
  const handleImageError = (e) => {
    console.error('Image failed to load:', e.target.src);
    
    // If the image is already a data URL, don't try to replace it again
    if (e.target.src.startsWith('data:')) {
      console.log('Already using data URL placeholder, skipping replacement');
      return;
    }
    
    // Use the data URL placeholder
    e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
    
    // Remove the error handler to prevent infinite loops
    e.target.onerror = null;
  };
        fetchAllContent();
      } else {
        throw new Error(response.data.message || 'Failed to delete item');
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      showNotification(error.response?.data?.message || 'Failed to delete item', 'error');
    }
  };

  // Update the prepareFormData function for home content
  const prepareFormData = async () => {
    const form = document.querySelector('form');
    const formEntries = new FormData(form);
    const data = new FormData();

    // Get the content type from editingItem if available, otherwise use activeTab
    const contentType = editingItem?._contentType || activeTab;

    try {
      switch (contentType) {
        case 'heroSlider':
          // Handle the entire hero slider array
          const slides = [];
          const slideCount = parseInt(formEntries.get('slideCount') || '0');
          for (let i = 0; i < slideCount; i++) {
            slides.push({
              title: formEntries.get(`slides[${i}].title`) || '',
              description: formEntries.get(`slides[${i}].description`) || '',
              image: editingItem.slides[i]?.image || '',
              isActive: formEntries.get(`slides[${i}].isActive`) === 'on',
              order: parseInt(formEntries.get(`slides[${i}].order`) || i)
            });
          }
          data.append('heroSlider', JSON.stringify(slides));
          break;

        case 'hero-slide':
          data.append('title', formEntries.get('title') || '');
          data.append('description', formEntries.get('description') || '');
          // Only append image if it exists in editingItem (from Cloudinary)
          if (editingItem.image) {
            data.append('image', editingItem.image);
          }
          data.append('isActive', formEntries.get('isActive') === 'on' ? 'true' : 'false');
          data.append('order', formEntries.get('order') || '0');
          break;

        case 'introduction':
          data.append('heading', formEntries.get('heading') || '');
          data.append('description', formEntries.get('description') || '');
          
          // Handle highlights array
          const highlights = [];
          const highlightCount = parseInt(formEntries.get('highlightCount') || '0');
          for (let i = 0; i < highlightCount; i++) {
            highlights.push({
              title: formEntries.get(`highlights[${i}].title`) || '',
              subtitle: formEntries.get(`highlights[${i}].subtitle`) || '',
              icon: formEntries.get(`highlights[${i}].icon`) || 'fa-calendar'
            });
          }
          data.append('highlights', JSON.stringify(highlights));

          // Handle download section
          data.append('download', JSON.stringify({
            label: formEntries.get('download.label') || '',
            fileName: formEntries.get('download.fileName') || '',
            url: editingItem.download?.url || ''
          }));
          break;

        case 'about':
          data.append('heading', formEntries.get('heading') || '');
          data.append('description', formEntries.get('description') || '');
          if (formEntries.get('image') instanceof File) {
            data.append('image', formEntries.get('image'));
          } else if (formEntries.get('image')) {
            data.append('image', formEntries.get('image'));
          }
          
          // Handle features array
          const features = [];
          const featureCount = parseInt(formEntries.get('featureCount') || '0');
          for (let i = 0; i < featureCount; i++) {
            features.push({
              title: formEntries.get(`features[${i}].title`) || '',
              description: formEntries.get(`features[${i}].description`) || ''
            });
          }
          data.append('features', JSON.stringify(features));
          break;

        case 'leadership':
          // Handle leadership section fields
          data.append('heading', formEntries.get('heading') || '');
          data.append('description', formEntries.get('description') || '');
          data.append('note', formEntries.get('note') || '');
          
          // Handle members array
          const members = [];
          const memberCount = parseInt(formEntries.get('memberCount') || '0');
          for (let i = 0; i < memberCount; i++) {
            const memberData = {
              name: formEntries.get(`members[${i}].name`) || '',
              position: formEntries.get(`members[${i}].title`) || '',
              description: formEntries.get(`members[${i}].description`) || '',
              image: editingItem.members[i]?.image || null // Include the existing image URL
            };
            
            // Handle member image
            if (selectedFiles[i]) {
              data.append(`memberImage${i}`, selectedFiles[i]);
            }
            
            members.push(memberData);
          }
          data.append('members', JSON.stringify(members));
          break;

        case 'event-category':
          data.append('title', formEntries.get('title') || '');
          data.append('description', formEntries.get('description') || '');
          data.append('icon', formEntries.get('icon') || '');
          data.append('capacity', formEntries.get('capacity') || '');
          if (formEntries.get('image') instanceof File) {
            data.append('image', formEntries.get('image'));
          } else if (formEntries.get('image')) {
            data.append('image', formEntries.get('image'));
          }
          data.append('membershipPricing', JSON.stringify({
            samajMember: formEntries.get('samajMember') || '',
            nonSamajMember: formEntries.get('nonSamajMember') || ''
          }));
          data.append('isActive', formEntries.get('isActive') === 'on' ? 'true' : 'false');
          break;

        case 'gallery':
          if (formEntries.get('file') instanceof File) {
            data.append('file', formEntries.get('file'));
          }
          // Ensure category and type are always set with valid values
          const category = formEntries.get('category') || 'weddings';
          // Validate category against allowed values
          const validCategories = ['weddings', 'corporate', 'birthdays', 'social', 'graduation', 'private'];
          const validCategory = validCategories.includes(category) ? category : 'weddings';
          
          const type = formEntries.get('type') || 'photo';
          data.append('category', validCategory);
          data.append('type', type);
          break;

        default:
          console.error('Invalid content type:', contentType);
          throw new Error(`Invalid content type: ${contentType}`);
      }

      return data;
    } catch (error) {
      console.error('Error preparing form data:', error);
      throw error;
    }
  };

  // Update the handleSubmit function for home content
  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      const contentType = editingItem._contentType;
      let response;
      let formData;

      formData = await prepareFormData();
      
      switch (contentType) {
        case 'heroSlider':
          // Update the entire hero slider
          const slidesData = JSON.parse(formData.get('heroSlider'));
          response = await axiosInstance.put('/api/content/home/hero-slider', {
            heroSlider: slidesData  // Changed from slides to heroSlider
          });
          break;
          
        case 'hero-slide':
          if (editingItem?._id) {
            console.log('Updating slide with data:', {
              id: editingItem._id,
              formData: Object.fromEntries(formData.entries())
            });
            // Convert FormData to JSON object
            const slideData = {
              title: formData.get('title'),
              description: formData.get('description'),
              image: editingItem.image,
              isActive: formData.get('isActive') === 'true',
              order: parseInt(formData.get('order') || '0')
            };
            response = await axiosInstance.put(`/api/content/home/hero-slide/${editingItem._id}`, slideData);
          } else {
            console.log('Creating new slide with data:', {
              formData: Object.fromEntries(formData.entries())
            });
            // Convert FormData to JSON object
            const slideData = {
              title: formData.get('title'),
              description: formData.get('description'),
              image: editingItem.image,
              isActive: formData.get('isActive') === 'true',
              order: parseInt(formData.get('order') || '0')
            };
            response = await axiosInstance.post(`/api/content/home/hero-slide`, slideData);
          }
          break;
          
        case 'introduction':
          const form = document.querySelector('form');
          const formEntries = new FormData(form);
          
          // Create a new FormData for the introduction update
          const introFormData = new FormData();
          introFormData.append('heading', formEntries.get('heading'));
          introFormData.append('description', formEntries.get('description'));
          introFormData.append('highlights', formEntries.get('highlights'));
          introFormData.append('downloadLabel', formEntries.get('downloadLabel'));
          
          // Handle PDF file upload
          const pdfFile = formEntries.get('pdfFile');
          if (pdfFile instanceof File) {
            introFormData.append('pdfFile', pdfFile);
          }
          
          response = await axiosInstance.put(`/api/content/home/introduction`, introFormData, {
            headers: {
              'Content-Type': 'multipart/form-data'
            }
          });
          break;
          
        case 'about':
          response = await axiosInstance.put(`/api/content/home/about`, formData, {
            headers: {
              'Content-Type': 'multipart/form-data'
            }
          });
          break;
          
        case 'leadership':
          // Update the leadership section with all members in one request
          response = await axiosInstance.put(`/api/content/home/leadership`, formData, {
            headers: {
              'Content-Type': 'multipart/form-data'
            }
          });
          break;
          
        case 'gallery':
          if (editingItem._id) {
            response = await axiosInstance.put(`/api/content/gallery/${editingItem._id}`, formData, {
              headers: {
                'Content-Type': 'multipart/form-data'
              }
            });
          } else {
            response = await axiosInstance.post(`/api/content/gallery`, formData, {
              headers: {
                'Content-Type': 'multipart/form-data'
              }
            });
          }
          break;
          
        case 'event-category':
          try {
            console.log('Starting event category submission with editingItem:', editingItem);
            
            const formData = new FormData();
            const form = document.querySelector('form');
            const formEntries = new FormData(form);
            
            // Validate required fields
            const requiredFields = ['title', 'description', 'icon', 'capacity'];
            const missingFields = requiredFields.filter(field => !formEntries.get(field));
            
            if (missingFields.length > 0) {
              throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
            }
            
            // Add basic fields from form
            formData.append('title', formEntries.get('title'));
            formData.append('description', formEntries.get('description'));
            formData.append('icon', formEntries.get('icon'));
            formData.append('capacity', formEntries.get('capacity'));
            formData.append('isActive', formEntries.get('isActive') === 'on' ? 'true' : 'false');
            formData.append('order', formEntries.get('order') || '0');

            // Generate an id from the title if not editing
            if (!editingItem._id) {
              const id = formEntries.get('title').toLowerCase().replace(/\s+/g, '-');
              formData.append('id', id);
            }
            
            // Handle image
            const imageFile = formEntries.get('image');
            if (imageFile instanceof File) {
              formData.append('image', imageFile);
            } else if (editingItem.image) {
              formData.append('image', editingItem.image);
            }
            
            // Handle membership pricing
            const membershipPricing = {
              samajMember: formEntries.get('samajMember'),
              nonSamajMember: formEntries.get('nonSamajMember')
            };
            
            if (!membershipPricing.samajMember || !membershipPricing.nonSamajMember) {
              throw new Error('Both Samaj Member and Non-Samaj Member pricing are required');
            }
            
            formData.append('membershipPricing', JSON.stringify(membershipPricing));
            
            // Handle features
            const features = [];
            const featureInputs = form.querySelectorAll('[name^="features["]');
            featureInputs.forEach(input => {
              if (input.value) features.push(input.value);
            });
            formData.append('features', JSON.stringify(features));

            // Log the complete form data before submission
            console.log('Form data to be submitted:', Object.fromEntries(formData.entries()));
            
            let response;
            if (editingItem._id) {
              // Update existing category
              console.log('Updating existing category:', editingItem._id);
              response = await axiosInstance.put(
                `/api/content/events/categories/${editingItem._id}`,
                formData,
                {
                  headers: {
                    'Content-Type': 'multipart/form-data'
                  }
                }
              );
            } else {
              // Create new category
              console.log('Creating new category');
              response = await axiosInstance.post(
                `/api/content/events/categories`,
                formData,
                {
                  headers: {
                    'Content-Type': 'multipart/form-data'
                  }
                }
              );
            }

            // Check if the response indicates success
            if (response?.data?.success) {
              toast.success(response.data.message || `Event category ${editingItem._id ? 'updated' : 'created'} successfully`);
              setEditingItem(null);
              setIsEditing(false);
              setIsAdding(false);
              await fetchAllContent();
              return; // Exit the function after successful save
            }

            // If we get here without a success response, throw an error
            throw new Error(response?.data?.message || 'Failed to save event category');
            
          } catch (error) {
            console.error('Error saving event category:', {
              message: error.message,
              response: error.response?.data,
              status: error.response?.status,
              stack: error.stack
            });
            const errorMessage = error.response?.data?.message || error.message || 'Failed to save event category';
            toast.error(errorMessage);
            setError(errorMessage);
            throw error; // Re-throw the error to be caught by the outer try-catch
          }
          break;
          
        default:
          console.error('Invalid content type:', contentType);
          throw new Error(`Invalid content type: ${contentType}`);
      }

      // Only handle non-event-category content types here
      if (contentType !== 'event-category' && response?.data?.success) {
        toast.success(response.data.message || `${contentType.replace('-', ' ')} ${editingItem?._id ? 'updated' : 'added'} successfully`);
        setEditingItem(null);
        setIsEditing(false);
        setIsAdding(false);
        await fetchAllContent();
      }
    } catch (err) {
      console.error('Error submitting form:', err);
      const errorMessage = err.response?.data?.message || err.message || 'An error occurred while saving the content';
      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Render content based on active tab
  const renderContent = () => {
    if (loading) return <div className="py-8 text-center">Loading content...</div>;
    if (error) return <div className="py-8 text-center text-red-500">{error}</div>;

    switch (activeTab) {
      case 'home':
        return renderHomeContent();
      case 'events':
        return renderEventCategories();
      case 'gallery':
        return renderGalleryItems();
      default:
        return null;
    }
  };

  const renderHomeContent = () => {
    console.log('Rendering home content:', homeContent);
    
    return (
      <div className="space-y-8">
        {/* Hero Slider Section */}
        <div className="card-hover p-6">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold">Hero Slider</h3>
            <button
              onClick={() => {
                setEditingItem({
                  _contentType: 'heroSlider',
                  slides: homeContent?.heroSlider || []
                });
                setIsEditing(true);
              }}
              className="flex items-center space-x-2 text-purple-600 hover:text-purple-700"
            >
              <PencilIcon className="h-5 w-5" />
              <span>Edit Slider</span>
            </button>
          </div>
          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {homeContent?.heroSlider?.map((slide, index) => (
                <div key={index} className="glass-effect rounded-lg overflow-hidden">
                  <div className="aspect-w-16 aspect-h-9">
                    <img
                      src={getImageUrl(slide.image)}
                      alt={slide.title}
                      className="w-full h-full object-cover"
                      onError={handleImageError}
                    />
                  </div>
                  <div className="p-4">
                    <h4 className="font-medium text-white">{slide.title}</h4>
                    <p className="text-sm text-neutral-300 mt-1">{slide.description}</p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* Introduction Section */}
        <div className="card-hover p-6">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold">Introduction Section</h3>
            <button
              onClick={() => {
                setEditingItem({
                  _contentType: 'introduction',
                  heading: homeContent?.introduction?.heading || '',
                  description: homeContent?.introduction?.description || '',
                  highlights: homeContent?.introduction?.highlights || [],
                  download: homeContent?.introduction?.download || {
                    label: '',
                    url: '',
                    fileName: ''
                  }
                });
                setIsEditing(true);
              }}
              className="flex items-center space-x-2 text-purple-600 hover:text-purple-700"
            >
              <PencilIcon className="h-5 w-5" />
              <span>Edit Introduction</span>
            </button>
          </div>
          <div className="space-y-4">
            <div>
              <h4 className="font-medium text-white">Heading</h4>
              <p className="text-neutral-300">{homeContent?.introduction?.heading}</p>
            </div>
            <div>
              <h4 className="font-medium text-white">Description</h4>
              <p className="text-neutral-300">{homeContent?.introduction?.description}</p>
            </div>
            <div>
              <h4 className="font-medium text-white">Highlights</h4>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-2">
                {homeContent?.introduction?.highlights?.map((highlight, index) => (
                  <div key={index} className="glass-effect p-4 rounded-lg">
                    <div className="flex items-center space-x-2 mb-2">
                      {getIconComponent(highlight.icon)}
                      <h5 className="font-medium">{highlight.title}</h5>
                    </div>
                    <p className="text-sm text-neutral-300">{highlight.subtitle}</p>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <h4 className="font-medium text-white">Download Section</h4>
              <div className="mt-2">
                <p className="text-neutral-300">
                  Label: {homeContent?.introduction?.download?.label}
                </p>
                <p className="text-neutral-300">
                  File: {homeContent?.introduction?.download?.fileName}
                </p>
              </div>
            </div>
          </div>
        </div>

        {/* About Section */}
        <div className="card-hover p-6">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold">About Section</h3>
            <button
              onClick={() => {
                setEditingItem({
                  _contentType: 'about',
                  heading: homeContent?.about?.heading || '',
                  description: homeContent?.about?.description || '',
                  image: homeContent?.about?.image || '',
                  features: homeContent?.about?.features || []
                });
                setIsEditing(true);
              }}
              className="flex items-center space-x-2 text-purple-600 hover:text-purple-700"
            >
              <PencilIcon className="h-5 w-5" />
              <span>Edit About</span>
            </button>
          </div>
          <div className="grid md:grid-cols-2 gap-6">
            <div>
              <img
                src={getImageUrl(homeContent?.about?.image)}
                alt="About Section"
                className="w-full h-64 object-cover rounded-lg"
                onError={handleImageError}
              />
            </div>
            <div className="space-y-4">
              <div>
                <h4 className="font-medium text-white">Heading</h4>
                <p className="text-neutral-300">{homeContent?.about?.heading}</p>
              </div>
              <div>
                <h4 className="font-medium text-white">Description</h4>
                <p className="text-neutral-300">{homeContent?.about?.description}</p>
              </div>
              <div>
                <h4 className="font-medium text-white">Features</h4>
                <div className="space-y-2 mt-2">
                  {homeContent?.about?.features?.map((feature, index) => (
                    <div key={index} className="glass-effect p-3 rounded-lg">
                      <h5 className="font-medium text-white">{feature.title}</h5>
                      <p className="text-sm text-neutral-300">{feature.description}</p>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Leadership Section */}
        <div className="card-hover p-6">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold">Leadership Section</h3>
            <button
              onClick={() => {
                setEditingItem({
                  _contentType: 'leadership',
                  heading: homeContent?.leadership?.heading || '',
                  description: homeContent?.leadership?.description || '',
                  members: homeContent?.leadership?.members || [],
                  note: homeContent?.leadership?.note || ''
                });
                setIsEditing(true);
              }}
              className="flex items-center space-x-2 text-purple-600 hover:text-purple-700"
            >
              <PencilIcon className="h-5 w-5" />
              <span>Edit Leadership</span>
            </button>
          </div>
          <div className="space-y-4">
            <div>
              <h4 className="font-medium text-white">Heading</h4>
              <p className="text-neutral-300">{homeContent?.leadership?.heading}</p>
            </div>
            <div>
              <h4 className="font-medium text-white">Description</h4>
              <p className="text-neutral-300">{homeContent?.leadership?.description}</p>
            </div>
            <div>
              <h4 className="font-medium text-white">Team Members</h4>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-2">
                {homeContent?.leadership?.members?.map((member, index) => (
                  <div key={index} className="glass-effect p-4 rounded-lg">
                    <img
                      src={getImageUrl(member.image)}
                      alt={member.name}
                      className="w-full h-48 object-cover rounded-lg mb-3"
                      onError={handleImageError}
                    />
                    <h5 className="font-medium text-white">{member.name}</h5>
                    <p className="text-sm text-neutral-300">{member.position}</p>
                    <p className="text-sm text-neutral-300 mt-2">{member.description}</p>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <h4 className="font-medium text-white">Note</h4>
              <p className="text-neutral-300">{homeContent?.leadership?.note}</p>
            </div>
          </div>
        </div>
      </div>
    );
  };

  const renderEventCategories = () => (
    <div className="space-y-6">
      <div className="card-hover p-6">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-semibold">Event Categories</h3>
          <button 
            onClick={() => {
              console.log('Adding new category');
              setEditingItem({ 
                _contentType: 'event-category',
                title: '',
                description: '',
                icon: '',
                capacity: '',
                image: '',
                membershipPricing: {
                  samajMember: '',
                  nonSamajMember: ''
                },
                features: [],
                packages: [],
                isActive: true,
                order: 0
              });
              setIsAdding(true);
            }}
            className="flex items-center space-x-2 text-purple-600 hover:text-purple-700"
          >
            <PlusIcon className="h-5 w-5" />
            <span>Add New Category</span>
          </button>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {eventCategories.map((category) => (
            <div key={category._id} className="glass-effect rounded-lg p-4 relative">
              <div className="absolute top-2 right-2 flex space-x-2">
                <button
                  onClick={() => {
                    setEditingItem({
                      ...category,
                      _contentType: 'event-category',
                      _id: category._id
                    });
                    setIsEditing(true);
                  }}
                  className="p-1.5 bg-neutral-700 rounded-full shadow"
                >
                  <PencilIcon className="h-4 w-4 text-blue-400" />
                </button>
                <button
                  onClick={() => handleDelete('event-category', category._id)}
                  className="p-1.5 bg-neutral-700 rounded-full shadow"
                >
                  <TrashIcon className="h-4 w-4 text-red-400" />
                </button>
              </div>
              <img
                src={getImageUrl(category.image)}
                alt={category.title}
                className="w-full h-48 object-cover rounded mb-3"
                onError={handleImageError}
              />
              <h4 className="font-semibold mb-2">{category.title}</h4>
              <p className="text-sm text-neutral-300 mb-2">{category.description}</p>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div>
                  <span className="text-neutral-400">Capacity:</span>
                  <span className="ml-1 text-white">{category.capacity}</span>
                </div>
                <div>
                  <span className="text-neutral-400">Order:</span>
                  <span className="ml-1 text-white">{category.order}</span>
                </div>
              </div>
              <div className="mt-2">
                <span className={`text-xs px-2 py-1 rounded-full ${
                  category.isActive ? 'bg-green-500/20 text-green-300 border border-green-500/30' : 'bg-neutral-500/20 text-neutral-300 border border-neutral-500/30'
                }`}>
                  {category.isActive ? 'Active' : 'Inactive'}
                </span>
              </div>
              <div className="mt-3">
                <h5 className="text-sm font-medium text-white mb-2">Pricing:</h5>
                <div className="text-sm text-neutral-300">
                  <p>Samaj Member: {category.membershipPricing?.samajMember || 'Not set'}</p>
                  <p>Non-Samaj Member: {category.membershipPricing?.nonSamajMember || 'Not set'}</p>
                </div>
              </div>
              {category.features && category.features.length > 0 && (
                <div className="mt-3">
                  <h5 className="text-sm font-medium text-white mb-2">Features:</h5>
                  <ul className="text-sm text-neutral-300 list-disc list-inside">
                    {category.features.map((feature, index) => (
                      <li key={`${category._id}-feature-${index}`}>{feature}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  );

  const renderGalleryItems = () => (
    <div className="space-y-6">
      <div className="flex space-x-4 mb-4">
        <button 
          className={`px-4 py-2 rounded-lg ${galleryTab === 'photos' ? 'bg-gradient-electric text-white' : 'glass-effect'}`}
          onClick={() => setGalleryTab('photos')}
        >
          Photos
        </button>
        <button 
          className={`px-4 py-2 rounded-lg ${galleryTab === 'videos' ? 'bg-gradient-electric text-white' : 'glass-effect'}`}
          onClick={() => setGalleryTab('videos')}
        >
          Videos
        </button>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {galleryItems.map((item) => (
          <div key={item._id} className="card-hover rounded-lg overflow-hidden">
            <div className="relative h-48">
              <img 
                src={getImageUrl(item.type === 'photo' ? item.url : item.thumbnail)}
                alt={item.title}
                className="w-full h-full object-cover"
                onError={(e) => {
                  handleImageError(e);
                }}
              />
              <div className="absolute top-2 right-2 flex space-x-2">
                <button 
                  onClick={() => {
                    setEditingItem({ 
                      ...item,
                      _contentType: 'gallery',
                      _id: item._id
                    });
                    setIsEditing(true);
                  }}
                  className="p-1.5 bg-neutral-700 rounded-full shadow"
                >
                  <PencilIcon className="h-4 w-4 text-blue-400" />
                </button>
                <button 
                  onClick={() => handleDelete('gallery', item._id)}
                  className="p-1.5 bg-neutral-700 rounded-full shadow"
                >
                  <TrashIcon className="h-4 w-4 text-red-400" />
                </button>
              </div>
            </div>
            <div className="p-4">
              <div className="flex justify-between items-center">
                <span className="text-sm font-medium bg-purple-500/20 text-purple-300 border border-purple-500/30 px-3 py-1 rounded-full capitalize">
                  {item.category}
                </span>
                <span className="text-xs text-neutral-400">
                  {item.type === 'photo' ? 'Photo' : 'Video'}
                </span>
              </div>
            </div>
          </div>
        ))}
      </div>

      <button 
        onClick={() => {
          setEditingItem({ 
            _contentType: 'gallery',
            type: galleryTab === 'photos' ? 'photo' : 'video',
            url: '',
            thumbnail: '',
            category: 'weddings'
          });
          setIsAdding(true);
        }}
        className="flex items-center space-x-2 text-purple-600 hover:text-purple-700"
      >
        <PlusIcon className="h-5 w-5" />
        <span>Add New {galleryTab === 'photos' ? 'Photo' : 'Video'}</span>
      </button>
    </div>
  );

  // Render edit form based on content type
  const renderEditForm = () => {
    if (!isEditing && !isAdding) return null;

    const contentType = editingItem._contentType;

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
        <div className="bg-neutral-800 rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto border border-neutral-700">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-semibold text-white">
              {isAdding ? 'Add' : 'Edit'} {contentType.replace('-', ' ')}
              </h3>
              <button
                onClick={() => {
                  setIsEditing(false);
                  setIsAdding(false);
                  setEditingItem(null);
                }}
              className="text-neutral-400 hover:text-white"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>

          <form onSubmit={handleSubmit} className="space-y-4">
            {/* Hero Slider Form */}
            {contentType === 'heroSlider' && (
              <>
                <input type="hidden" name="slideCount" value={editingItem.slides?.length || 0} />
                <div className="space-y-6">
                  {editingItem.slides?.map((slide, index) => (
                    <div key={index} className="border rounded-lg p-4 space-y-4 border-neutral-700 bg-neutral-900/50">
                      <div className="flex justify-between items-center">
                        <h4 className="text-lg font-medium text-white">Slide {index + 1}</h4>
                        <button
                          type="button"
                          onClick={() => {
                            const newSlides = [...editingItem.slides];
                            newSlides.splice(index, 1);
                            setEditingItem({ ...editingItem, slides: newSlides });
                          }}
                          className="text-red-400 hover:text-red-300"
                        >
                          <TrashIcon className="h-5 w-5" />
                        </button>
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-white">Title</label>
                        <input
                          type="text"
                          name={`slides[${index}].title`}
                          defaultValue={slide.title}
                          className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                          required
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-white">Description</label>
                        <textarea
                          name={`slides[${index}].description`}
                          defaultValue={slide.description}
                          className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                          rows="2"
                          required
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-white">Image</label>
                        <input
                          type="file"
                          name={`slides[${index}].image`}
                          className="mt-1 block w-full text-white"
                          accept="image/*"
                          onChange={async (e) => {
                            const file = e.target.files[0];
                            if (file) {
                              try {
                                const formData = new FormData();
                                formData.append('file', file);
                                formData.append('upload_preset', import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET);
                                formData.append('folder', FOLDERS.SLIDES);
                                
                                const response = await fetch(
                                  `https://api.cloudinary.com/v1_1/${import.meta.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
                                  {
                                    method: 'POST',
                                    body: formData,
                                  }
                                );

                                if (!response.ok) {
                                  throw new Error('Upload failed');
                                }

                                const data = await response.json();
                                if (data.secure_url) {
                                  const newSlides = [...editingItem.slides];
                                  newSlides[index] = {
                                    ...newSlides[index],
                                    image: data.secure_url
                                  };
                                  setEditingItem(prev => ({
                                    ...prev,
                                    slides: newSlides
                                  }));
                                  toast.success('Image uploaded successfully');
                                }
                              } catch (error) {
                                console.error('Error uploading image:', error);
                                toast.error('Failed to upload image');
                              }
                            }
                          }}
                        />
                        {slide.image && (
                          <img
                            src={getImageUrl(slide.image)}
                            alt={`Slide ${index + 1}`}
                            className="mt-2 h-32 w-auto object-cover rounded"
                            onError={handleImageError}
                          />
                        )}
                      </div>
                      
                      <div className="flex items-center">
                        <input
                          type="checkbox"
                          name={`slides[${index}].isActive`}
                          defaultChecked={slide.isActive}
                          className="h-4 w-4 text-electric-500 focus:ring-electric-500 border-neutral-600 rounded bg-neutral-700"
                        />
                        <label className="ml-2 block text-sm text-white">
                          Active
                        </label>
                      </div>
                    </div>
                  ))}
                  
                  <button
                    type="button"
                    onClick={() => {
                      const newSlides = [
                        ...(editingItem.slides || []),
                        { title: '', description: '', image: '', isActive: true }
                      ];
                      setEditingItem({ ...editingItem, slides: newSlides });
                    }}
                    className="mt-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gradient-electric hover:from-electric-600 hover:to-electric-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-electric-500"
                  >
                    <PlusIcon className="h-5 w-5 mr-2" />
                    Add Slide
                  </button>
                </div>
              </>
            )}

            {/* Hero Slide Form */}
            {contentType === 'hero-slide' && (
              <>
                <div>
                  <label className="block text-sm font-medium text-white">Title</label>
                  <input
                    type="text"
                    name="title"
                    defaultValue={editingItem.title || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Description</label>
                  <textarea
                    name="description"
                    defaultValue={editingItem.description || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    rows="3"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Image</label>
                  <input
                    type="file"
                    name="image"
                    className="mt-1 block w-full"
                    accept="image/*"
                    onChange={async (e) => {
                      const file = e.target.files[0];
                      if (file) {
                        try {
                          const formData = new FormData();
                          formData.append('file', file);
                          formData.append('upload_preset', import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET);
                          formData.append('folder', FOLDERS.SLIDES);
                          
                          console.log('Uploading to Cloudinary with config:', {
                            cloudName: import.meta.env.VITE_CLOUDINARY_CLOUD_NAME,
                            uploadPreset: import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET,
                            folder: FOLDERS.SLIDES,
                            fileName: file.name,
                            fileType: file.type,
                            fileSize: file.size
                          });
                          
                          const response = await fetch(
                            `https://api.cloudinary.com/v1_1/${import.meta.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
                            {
                              method: 'POST',
                              body: formData,
                            }
                          );

                          if (!response.ok) {
                            const errorData = await response.json();
                            console.error('Cloudinary upload failed:', errorData);
                            throw new Error(`Upload failed: ${errorData.error?.message || 'Unknown error'}`);
                          }

                          const data = await response.json();
                          console.log('Upload successful:', data);
                          
                          if (data.secure_url) {
                            setEditingItem(prev => ({
                              ...prev,
                              image: data.secure_url
                            }));
                            toast.success('Image uploaded successfully');
                          } else {
                            throw new Error('No secure URL in response');
                          }
                        } catch (error) {
                          console.error('Error uploading image to Cloudinary:', error);
                          toast.error('Failed to upload image: ' + (error.message || 'Unknown error'));
                        }
                      }
                    }}
                  />
                  {editingItem.image && (
                    <img
                      src={getImageUrl(editingItem.image)}
                      alt="Preview"
                      className="mt-2 h-32 w-auto object-cover rounded"
                      onError={handleImageError}
                    />
                  )}
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Order</label>
                  <input
                    type="number"
                    name="order"
                    defaultValue={editingItem.order || 0}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    min="0"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    name="isActive"
                    defaultChecked={editingItem.isActive !== false}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-white">Active</label>
                </div>
              </>
            )}

            {/* Introduction Form */}
            {contentType === 'introduction' && (
              <>
                <div>
                  <label className="block text-sm font-medium text-white">Heading</label>
                  <input
                    type="text"
                    name="heading"
                    defaultValue={editingItem.heading || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Description</label>
                  <textarea
                    name="description"
                    defaultValue={editingItem.description || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    rows="4"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Highlights</label>
                  <input type="hidden" name="highlightCount" value={editingItem.highlights?.length || 0} />
                  <div className="space-y-4 mt-2">
                    {editingItem.highlights?.map((highlight, index) => (
                      <div key={index} className="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 glass-effect rounded-lg">
                        <div>
                          <label className="block text-sm font-medium text-white">Icon</label>
                          <input
                            type="text"
                            name={`highlights[${index}].icon`}
                            defaultValue={highlight.icon}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-white">Title</label>
                          <input
                            type="text"
                            name={`highlights[${index}].title`}
                            defaultValue={highlight.title}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-white">Subtitle</label>
                          <input
                            type="text"
                            name={`highlights[${index}].subtitle`}
                            defaultValue={highlight.subtitle}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Download Section</label>
                  <div className="mt-2 space-y-4">
                    <div>
                      <label className="block text-sm text-white">Download Label</label>
                      <input
                        type="text"
                        name="downloadLabel"
                        defaultValue={editingItem.download?.label || 'Download PDF'}
                        className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                      />
                    </div>
                    <div>
                      <label className="block text-sm text-white">PDF File</label>
                      <input
                        type="file"
                        name="pdfFile"
                        accept=".pdf"
                        className="mt-1 block w-full"
                      />
                      {editingItem.download?.fileName && (
                        <p className="mt-2 text-sm text-neutral-300">
                          Current file: {editingItem.download.fileName}
                        </p>
                      )}
                    </div>
                  </div>
                </div>
              </>
            )}

            {/* About Form */}
            {contentType === 'about' && (
              <>
                <div>
                  <label className="block text-sm font-medium text-white">Heading</label>
                  <input
                    type="text"
                    name="heading"
                    defaultValue={editingItem.heading || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Description</label>
                  <textarea
                    name="description"
                    defaultValue={editingItem.description || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    rows="4"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Image</label>
                  <input
                    type="file"
                    name="image"
                    className="mt-1 block w-full"
                    accept="image/*"
                  />
                  {editingItem.image && (
                    <img
                      src={getImageUrl(editingItem.image)}
                      alt="Preview"
                      className="mt-2 h-32 w-auto object-cover rounded"
                    />
                  )}
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Features</label>
                  <input type="hidden" name="featureCount" value={editingItem.features?.length || 0} />
                  <div className="space-y-4 mt-2">
                    {editingItem.features?.map((feature, index) => (
                      <div key={index} className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 glass-effect rounded-lg">
                        <div>
                          <label className="block text-sm font-medium text-white">Title</label>
                          <input
                            type="text"
                            name={`features[${index}].title`}
                            defaultValue={feature.title}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-white">Description</label>
                          <input
                            type="text"
                            name={`features[${index}].description`}
                            defaultValue={feature.description}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                      </div>
                    ))}
                    <button
                      type="button"
                      onClick={() => {
                        const newFeatures = [...editingItem.features];
                        newFeatures.splice(index, 1);
                        setEditingItem({ ...editingItem, features: newFeatures });
                      }}
                      className="text-red-600 hover:text-red-700"
                    >
                      <TrashIcon className="h-5 w-5" />
                    </button>
                  </div>
                </div>
              </>
            )}

            {/* Leadership Form */}
            {contentType === 'leadership' && (
              <>
                <div>
                  <label className="block text-sm font-medium text-white">Heading</label>
                  <input
                    type="text"
                    name="heading"
                    defaultValue={editingItem.heading || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Description</label>
                  <textarea
                    name="description"
                    defaultValue={editingItem.description || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    rows="4"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Note</label>
                  <textarea
                    name="note"
                    defaultValue={editingItem.note || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    rows="2"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Team Members</label>
                  <input type="hidden" name="memberCount" value={editingItem.members?.length || 0} />
                  <div className="space-y-4 mt-2">
                    {editingItem.members?.map((member, index) => (
                      <div key={index} className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 glass-effect rounded-lg">
                        <div>
                          <label className="block text-sm font-medium text-white">Name</label>
                          <input
                            type="text"
                            name={`members[${index}].name`}
                            defaultValue={member.name}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-white">Position</label>
                          <input
                            type="text"
                            name={`members[${index}].title`}
                            defaultValue={member.position}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            required
                          />
                        </div>
                        <div className="md:col-span-2">
                          <label className="block text-sm font-medium text-white">Description</label>
                          <textarea
                            name={`members[${index}].description`}
                            defaultValue={member.description}
                            className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                            rows="2"
                            required
                          />
                        </div>
                        <div className="md:col-span-2">
                          <label className="block text-sm font-medium text-white">Image</label>
                          <input
                            type="file"
                            name={`members[${index}].image`}
                            className="mt-1 block w-full text-white"
                            accept="image/*"
                            onChange={async (e) => {
                              const file = e.target.files[0];
                              if (file) {
                                try {
                                  const formData = new FormData();
                                  formData.append('file', file);
                                  formData.append('upload_preset', import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET);
                                  formData.append('folder', FOLDERS.LEADERSHIP);
                                  
                                  const response = await fetch(
                                    `https://api.cloudinary.com/v1_1/${import.meta.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
                                    {
                                      method: 'POST',
                                      body: formData,
                                    }
                                  );

                                  if (!response.ok) {
                                    throw new Error('Upload failed');
                                  }

                                  const data = await response.json();
                                  if (data.secure_url) {
                                    // Update the member's image in the editingItem state
                                    const updatedMembers = [...editingItem.members];
                                    updatedMembers[index] = {
                                      ...updatedMembers[index],
                                      image: data.secure_url
                                    };
                                    setEditingItem(prev => ({
                                      ...prev,
                                      members: updatedMembers
                                    }));
                                    toast.success('Image uploaded successfully');
                                  }
                                } catch (error) {
                                  console.error('Error uploading image:', error);
                                  toast.error('Failed to upload image');
                                }
                              }
                            }}
                          />
                          {member.image && (
                            <img
                              src={getImageUrl(member.image)}
                              alt={member.name}
                              className="mt-2 h-32 w-auto object-cover rounded"
                              onError={handleImageError}
                            />
                          )}
                        </div>
                        <div className="md:col-span-2 flex justify-end">
                          <button
                            type="button"
                            onClick={() => {
                              if (member._id) {
                                handleDelete('leadership-member', member._id);
                              } else {
                                const newMembers = [...editingItem.members];
                                newMembers.splice(index, 1);
                                setEditingItem({ ...editingItem, members: newMembers });
                              }
                            }}
                            className="text-red-600 hover:text-red-700 flex items-center gap-1"
                          >
                            <TrashIcon className="h-5 w-5" />
                            <span>Remove Member</span>
                          </button>
                        </div>
                      </div>
                    ))}
                    <button
                      type="button"
                      onClick={() => {
                        const newMembers = [...(editingItem.members || []), { name: '', position: '', description: '', image: '' }];
                        setEditingItem({ ...editingItem, members: newMembers });
                      }}
                      className="mt-2 text-blue-500 hover:text-blue-700 flex items-center gap-1"
                    >
                      <PlusIcon className="h-5 w-5" />
                      Add Team Member
                    </button>
                  </div>
                </div>
              </>
            )}

            {/* Event Category Form */}
            {contentType === 'event-category' && (
              <>
                <div>
                  <label className="block text-sm font-medium text-white">Title</label>
                  <input
                    type="text"
                    name="title"
                    defaultValue={editingItem.title || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Description</label>
                  <textarea
                    name="description"
                    defaultValue={editingItem.description || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    rows="3"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Icon</label>
                  <input
                    type="text"
                    name="icon"
                    defaultValue={editingItem.icon || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Capacity</label>
                  <input
                    type="text"
                    name="capacity"
                    defaultValue={editingItem.capacity || ''}
                    className="mt-1 block w-full rounded-md border-neutral-600 shadow-sm focus:border-electric-500 focus:ring-electric-500 bg-neutral-800 text-white"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Image</label>
                  <input
                    type="file"
                    name="image"
                    className="mt-1 block w-full"
                    accept="image/*"
                    onChange={async (e) => {
                      const file = e.target.files[0];
                      if (file) {
                        try {
                          const formData = new FormData();
                          formData.append('file', file);
                          formData.append('upload_preset', import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET);
                          formData.append('folder', FOLDERS.EVENTS);
                          
                          const response = await fetch(
                            `https://api.cloudinary.com/v1_1/${import.meta.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
                            {
                              method: 'POST',
                              body: formData,
                            }
                          );

                          if (!response.ok) {
                            throw new Error('Upload failed');
                          }

                          const data = await response.json();
                          if (data.secure_url) {
                            setEditingItem(prev => ({
                              ...prev,
                              image: data.secure_url
                            }));
                            toast.success('Image uploaded successfully');
                          }
                        } catch (error) {
                          console.error('Error uploading image:', error);
                          toast.error('Failed to upload image');
                        }
                      }
                    }}
                  />
                  {editingItem.image && (
                    <img
                      src={getImageUrl(editingItem.image)}
                      alt="Preview"
                      className="mt-2 h-32 w-auto object-cover rounded"
                      onError={handleImageError}
                    />
                  )}
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Membership Pricing</label>
                  <div className="grid grid-cols-2 gap-4 mt-2">
                    <div>
                      <label className="block text-sm text-neutral-300">Samaj Member</label>
                      <input
                        type="text"
                        name="samajMember"
                        defaultValue={editingItem.membershipPricing?.samajMember || ''}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                        required
                      />
                    </div>
                    <div>
                      <label className="block text-sm text-neutral-300">Non-Samaj Member</label>
                      <input
                        type="text"
                        name="nonSamajMember"
                        defaultValue={editingItem.membershipPricing?.nonSamajMember || ''}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                        required
                      />
                    </div>
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Features</label>
                  <input type="hidden" name="featureCount" value={editingItem.features?.length || 0} />
                  <div className="space-y-4 mt-2">
                    {editingItem.features?.map((feature, index) => (
                      <div key={index} className="flex items-center gap-2">
                        <input
                          type="text"
                          name={`features[${index}]`}
                          defaultValue={feature}
                          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                          required
                        />
                        <button
                          type="button"
                          onClick={() => {
                            const newFeatures = [...editingItem.features];
                            newFeatures.splice(index, 1);
                            setEditingItem({ ...editingItem, features: newFeatures });
                          }}
                          className="text-red-600 hover:text-red-700"
                        >
                          <TrashIcon className="h-5 w-5" />
                        </button>
                      </div>
                    ))}
                    <button
                      type="button"
                      onClick={() => {
                        const newFeatures = [...(editingItem.features || []), ''];
                        setEditingItem({ ...editingItem, features: newFeatures });
                      }}
                      className="mt-2 text-blue-500 hover:text-blue-700 flex items-center gap-1"
                    >
                      <PlusIcon className="h-5 w-5" />
                      Add Feature
                    </button>
                  </div>
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    name="isActive"
                    defaultChecked={editingItem.isActive !== false}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-white">Active</label>
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Order</label>
                  <input
                    type="number"
                    name="order"
                    defaultValue={editingItem.order || 0}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    min="0"
                  />
                </div>
              </>
            )}

            {/* Gallery Form */}
            {contentType === 'gallery' && (
              <>
                <div>
                  <label className="block text-sm font-medium text-white">File</label>
                  <input
                    type="file"
                    name="file"
                    className="mt-1 block w-full"
                    accept="image/*,video/*"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Category</label>
                  <select
                    name="category"
                    defaultValue={editingItem?.category || 'weddings'}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    required
                  >
                    <option value="weddings">Weddings</option>
                    <option value="corporate">Corporate</option>
                    <option value="birthdays">Birthdays</option>
                    <option value="social">Social</option>
                    <option value="graduation">Graduation</option>
                    <option value="private">Private</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-white">Type</label>
                  <select
                    name="type"
                    defaultValue={editingItem?.type || 'photo'}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                    required
                  >
                    <option value="photo">Photo</option>
                    <option value="video">Video</option>
                  </select>
                </div>
              </>
            )}

            <div className="flex justify-end gap-4 mt-6">
                <button
                  type="button"
                  onClick={() => {
                    setIsEditing(false);
                    setIsAdding(false);
                    setEditingItem(null);
                  }}
                className="px-4 py-2 glass-effect rounded-lg hover:bg-neutral-700"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
                >
                  {isAdding ? 'Add' : 'Save'}
                </button>
              </div>
            </form>
        </div>
      </div>
    );
  };

  // Helper function to get icon component
  const getIconComponent = (iconName) => {
    switch (iconName) {
      case 'fa-calendar':
        return <FaCalendar className="text-2xl text-purple-600" />;
      case 'fa-users':
        return <FaUsers className="text-2xl text-purple-600" />;
      case 'fa-gem':
        return <FaGem className="text-2xl text-purple-600" />;
      case 'fa-clock':
        return <FaClock className="text-2xl text-purple-600" />;
      case 'fa-download':
        return <FaDownload className="text-2xl text-purple-600" />;
      default:
        return null;
    }
  };

  const handleImageChange = (e, index) => {
    const file = e.target.files[0];
    if (file) {
      // Store the file
      setSelectedFiles(prev => ({
        ...prev,
        [index]: file
      }));
      
      // Create preview
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviewImages(prev => ({
          ...prev,
          [index]: reader.result
        }));
      };
      reader.readAsDataURL(file);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-mesh p-3 sm:p-6">
      {/* Main Content Container */}
      <div className="card-glass animate-fade-in-up">
        {/* Header Section - Responsive */}
        <div className="border-b border-white/10 pb-6 mb-6">
          <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4">
            <div className="flex items-center space-x-3">
              <div className="w-10 h-10 bg-gradient-electric rounded-xl flex items-center justify-center shadow-lg neon-glow">
                <PencilIcon className="w-6 h-6 text-white" />
              </div>
              <h2 className="text-xl sm:text-2xl font-bold text-white">Content Management</h2>
            </div>
            
            <div className="flex flex-wrap gap-2 justify-center sm:justify-end">
              <button 
                onClick={fetchAllContent}
                className="btn-secondary flex items-center space-x-2"
                title="Refresh"
              >
                <ArrowPathIcon className="h-4 w-4" />
                <span className="hidden sm:inline">Refresh</span>
              </button>
              <button 
                onClick={() => {
                  if (activeTab === 'home') {
                    setEditingItem({ 
                      _contentType: 'hero-slide',
                      image: '',
                      title: '',
                      description: '',
                      isActive: true
                    });
                  } else if (activeTab === 'events') {
                    setEditingItem({ 
                      _contentType: 'event-category',
                      title: '',
                      description: '',
                      capacity: '',
                      image: '',
                      membershipPricing: {
                        samajMember: '',
                        nonSamajMember: ''
                      },
                      features: [],
                      packages: [],
                      isActive: true
                    });
                  } else if (activeTab === 'gallery') {
                    setEditingItem({ 
                      _contentType: 'gallery',
                      type: galleryTab === 'photos' ? 'photo' : 'video',
                      url: '',
                      thumbnail: '',
                      category: 'weddings'
                    });
                  }
                  setIsAdding(true);
                }}
                className="btn-primary flex items-center space-x-2"
              >
                <PlusIcon className="h-4 w-4" />
                <span className="hidden sm:inline">Add New</span>
                <span className="sm:hidden">Add</span>
              </button>
            </div>
          </div>
        </div>

        <div className="space-y-6">
          {/* Content Type Tabs - Responsive */}
          <div className="flex flex-wrap gap-2 sm:gap-4">
            {contentTypes.map((type) => (
              <button
                key={type.id}
                onClick={() => setActiveTab(type.id)}
                className={`px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm font-medium transition-all duration-200 ${
                  activeTab === type.id
                    ? 'bg-gradient-electric text-white shadow-lg neon-glow'
                    : 'glass-effect text-neutral-300 hover:text-white border border-white/10 hover:border-electric-500/50'
                }`}
              >
                {type.name}
              </button>
            ))}
          </div>

          {/* Content Display */}
          {renderContent()}
        </div>

        {/* Edit/Add Modal */}
        {(isEditing || isAdding) && renderEditForm()}
      </div>
    </div>
  );
};

export default ContentManagement;